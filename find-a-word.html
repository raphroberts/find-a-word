<!DOCTYPE html>
<html>
<head>
	<style>	
	canvas {
	    cursor: crosshair;
	    border: 0px none black;
	}
	</style>
	<link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono&display=swap" rel="stylesheet">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.0/jquery.min.js" integrity="sha256-xNzN2a4ltkB44Mc/Jz3pT4iU1cmeR0FkXs4pru/JxaQ=" crossorigin="anonymous">
	</script>
</head>

<body>
	<p> Find the words "foreleg", "head", and "thorax" </p>
	<canvas id="canvas" width="410" height="430"></canvas>
	<div id="output"></div>
</body>

<script>
	
//Variables

var canvasx = $(canvas).offset().left;
var canvasy = $(canvas).offset().top;
var last_mousex = last_mousey = 0;
var mousex = mousey = 0;
var mousedown = false;

// Wordlist data
// 0,1 = X/Y start letter, 2,3 = X/Y end letter, 4 = word, 5=colour

var wordList = [
	[102,410,280,410,'foreleg','255,0,0,0.5'],
	[39,200,131,111,'head','0,255,0,0.5'],
	[309,202,309,351,'thorax','0,0,255,0.5']	
];

// Grid of letters

var letterString = "\
NASTRAPHTUOM\
SGNIWLIDAEMW\
WHJVAGBUOJBJ\
EJIDPJIUASVE\
FEANNETNBASA\
EERTDHLNMOHN\
HLVUPLEDUTPN\
BQCAMMEMTHAE\
YPRAOEIGOOFT\
ATHDRDFKNRTN\
IMBKLIBUOAGA\
BAWEJBPQRXFA\
ICGEYESSPYQS\
TPFORELEGEZJ";

// Array for storing previous words that are found

var previousLines = [];

// Positioning data for grid rendering

var xPadding = 30;
var yPadding = 30;
var xRenderLetter = xPadding;
var yRenderLetter = yPadding;
var gridSquareSize = 30;
var gridSquareOffset = 5;

// Count data for grid rendering

var columnCount = 1;
var maxColumns = 12;

// Initial render

$( document ).ready(function() {
	prepareCanvas();
	drawGrid();
});

function prepareCanvas() {
	//Prepares the HTML canvas
	
	var canvas = document.getElementById('canvas');
	ctx = canvas.getContext('2d');
	ctx.font='30px Courier New';
}

function drawGrid() {
	// Draws the grid of letters
	
	for (var i = 0; i < letterString.length; i++) {
		ctx.lineWidth = 1;
		ctx.strokeStyle = "#accddd";
		ctx.beginPath();
		ctx.rect(gridSquareSize - gridSquareOffset, 0 + gridSquareOffset, xRenderLetter, yRenderLetter);
		ctx.stroke();
		ctx.fillText(letterString.charAt(i), xRenderLetter, yRenderLetter);
		xRenderLetter += xPadding;
		columnCount += 1;
		
		// When columns created = maxColumns, create a new row
		if(columnCount > maxColumns){
			columnCount = 1;
			yRenderLetter += yPadding;
			xRenderLetter = xPadding;
		}
	}
	xRenderLetter = xPadding;
	yRenderLetter = yPadding;	
	columnCount = 1;
}

function drawPreviousLines(){
	// Draws the lines from previously found words

	for (var i = 0; i < previousLines.length; i++) {
		ctx.strokeStyle = "rgba(" + previousLines[i][4] +")";
		ctx.lineWidth = 20;
        ctx.lineJoin = ctx.lineCap = 'round';
        ctx.beginPath();
		ctx.moveTo(previousLines[i][0],previousLines[i][1]);
        ctx.lineTo(previousLines[i][2],previousLines[i][3]);
        ctx.stroke();
	}
}

function drawCurrentLine(e){
	// Draws a line from previous mousedown to current mouse position
	
	// Get current mouse position (end point of the line)
    mousex = parseInt(e.clientX-canvasx);
	mousey = parseInt(e.clientY-canvasy);
	
	// Draw a line from previously stored position to current position
	ctx.beginPath();
    ctx.moveTo(last_mousex,last_mousey);
    ctx.lineTo(mousex,mousey);
    ctx.strokeStyle = 'rgba(255,0,0,0.5)';
    ctx.lineWidth = 20;
    ctx.lineJoin = ctx.lineCap = 'round';
    ctx.stroke();
}

function checkFirstLetters(){
    // loop through wordList start coordinates and compare them to last_mousex
	// If the distance is < gridSquareSize, match found
	
	for (var i = 0; i < wordList.length; i++) {
		startX = wordList[i][0];
		startY = wordList[i][1];
		distanceX = startX - last_mousex;
		distanceY = startY - last_mousey;
		distance = Math.sqrt( distanceX*distanceX + distanceY*distanceY );
		console.log("Distance between selection and first letter is " + distance);
		
		// If distance of first letter is within the threshold, check the second letter
		if (distance < gridSquareSize){
			checkSecondLetter(i,startX,startY);
		}
	}
		
}

function checkSecondLetter(wordListIndex,startX,startY) {
	// Check distance between current selection and last letter's location < gridSquareSize
	
	endX = wordList[wordListIndex][2];
	endY = wordList[wordListIndex][3];
	distanceX = endX - mousex;
	distanceY = endY - mousey;
	distance = Math.sqrt( distanceX*distanceX + distanceY*distanceY );
	console.log("Distance between selection and last letter is " + distance);
	
	// If distance of second letter is within threshold, a word is found
	if (distance < gridSquareSize){
		alert("Word found: " + wordList[wordListIndex][4]);
		
		// Save the line data to previousLines array
		previousLines.push([startX,startY,mousex,mousey,wordList[wordListIndex][5]])
	}		
}

//Mousedown

$(canvas).on('mousedown', function(e) {
	// Save the mouse position and register the mouse event
	
    last_mousex = parseInt(e.clientX-canvasx);
	last_mousey = parseInt(e.clientY-canvasy);
    mousedown = true;
    
});

//Mouseup

$(canvas).on('mouseup', function(e) {
	// Register the mouse up and start checking for a match
	
    mousedown = false;
	checkFirstLetters();	
});

//Mousemove

$(canvas).on('mousemove', function(e) {
	// Continuously Redraw the grid, previous lines, and current line
	
    if(mousedown) {
	    // Clear the canvas
        ctx.clearRect(0,0,canvas.width,canvas.height); 
        // Draw the grid, previous line, and the line currently being drawn
        drawGrid();
        drawPreviousLines();
        drawCurrentLine(e);
    }
	//Output
	$('#output').html('current: '+mousex+', '+mousey+'<br/>last: '+last_mousex+', '+last_mousey+'<br/>mousedown: '+mousedown);
});


</script>

</html>